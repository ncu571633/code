****************************************************************************************
C++20 takes string_view and makes it more generic via the std::span type
It serves as a non-owning, lightweight reference to a contiguous range of objects
Itâ€™s particularly useful in functions that need to operate on a portion of an array or a vector without requiring ownership of the data.
#include <iostream>
#include <span>
#include <vector>

void print(std::span<const int> sp) {
    for (int i : sp)
        std::cout << i << " ";
    std::cout << '\n';
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    std::span<int> sp(arr, 5);
    std::vector nums { 10, 11, 12, 13 };
    std::span<int> subSp = sp.subspan(1, 3);

    print(sp);
    print(nums);
    print(subSp);
}

****************************************************************************************
Range Views: Range Views enable lazy evaluation, which allows operations like filter, transform, 
or concatenate to be expressed in a readable, declarative style without immediate evaluation, often leading to performance improvements

#include <iostream>
#include <ranges>
#include <vector>

int main() {
    std::vector nums = {1, 2, 3, 4, 5, 6};
    
    auto even_nums = nums | std::views::filter([](int n) { 
        return n % 2 == 0; 
    });
    
    for (int n : even_nums)
        std::cout << n << " "; 
}


****************************************************************************************
Concept: a set of constraints on template parameters evaluated at compile time.
Write requirements for templates which the compiler can check
In template, type T could be any type. concept can make T only be double/int...

#include <numeric>
#include <vector>
#include <iostream>
#include <concepts>

template <typename T> 
requires std::integral<T> || std::floating_point<T>
constexpr double Average(std::vector<T> const &vec) {
    const double sum = std::accumulate(vec.begin(), vec.end(), 0.0);        
    return sum / vec.size();
}

int main() {
    std::vector ints { 1, 2, 3, 4, 5};
    std::cout << Average(ints) << '\n';                                      
}

template<typename T>
concept Integral = std::is_integral<T>::value;
Integral auto gcd(Integral auto a,     
                  Integral auto b){
    if( b == 0 ) return a; 
    else return gcd(b, a % b);
}


template<typename T>
concept has_string_data_member = requires(T v) { 
    { v.name_ } -> std::convertible_to<std::string>; 
};

struct Person {
    int age_ { 0 };
    std::string name_;
};

struct Box {
    double weight_ { 0.0 };
    double volume_ { 0.0 };
};

int main() {
    static_assert(has_string_data_member<Person>);
    static_assert(!has_string_data_member<Box>);
}

****************************************************************************************
