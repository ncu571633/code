Padding:
Many processors expect memory for variables to be aligned based on the size of the variable. 
the structure padding is automatically done by the compiler to make sure all its members are byte aligned.
A ‘char’ of 1 byte can be allocated anywhere in memory like 0x5000 or 0x5001. 
An ‘int’ of 4 bytes, must start at a 4-byte boundary like 0x5004 or 0x5008. T

Overload
#include <iostream>
using namespace std;

class Date
{
    int mo, da, yr;
public:
    friend ostream& operator<<(ostream& os, const Date& dt);
    friend istream& operator>> (istream& is, Date& dt);
};

ostream& operator<<(ostream& os, const Date& dt)
{
    os << dt.mo << '/' << dt.da << '/' << dt.yr;
    return os;
}

istream& operator>> (istream& is, Date& dt)
{
    is>> dt.mo>> dt.da>> dt.yr;
    return is;
}


int main()
{
    Date dt;
    cin >> dt;
    cout << dt;
}

    Complex operator+(Complex const& obj)
    {
        Complex res;
        res.real = real + obj.real;
        res.imag = imag + obj.imag;
        return res;
    }



Bitfields: save space. They also allow an easier way to set values that aren't byte-aligned. 
1. A special unnamed bit field of size 0 is used to force alignment on the next boundary
2. We cannot have pointers to bit field members as they may not start at a byte boundary. 
3. It is implementation-defined to assign an out-of-range value to a bit field member. 
4. In C++, we can have static members in a structure/class, but bit fields cannot be static. 
5. Array of bit fields is not allowed. For example, the below program fails in the compilation. 

https://www.geeksforgeeks.org/bit-fields-c/


struct
{
    unsigned short icon : 8;
    unsigned short color : 4;
    unsigned short underline : 1;
    unsigned short blink : 1;
} test1;

struct mybitfields
{
    unsigned short a : 4;
    unsigned short b : 5;
    unsigned short c : 7;
} test2;

struct
{
    unsigned int first : 9;
    unsigned int second : 7;
    unsigned int may_straddle : 5;
    unsigned int last : 5;
} test3;

cout<< sizeof(test1) << sizeof(unsigned short) << endl;
cout<< sizeof(test2) << endl;
cout<< sizeof(test3) << endl;


https://www.stroustrup.com/C++11FAQ.html
https://en.wikipedia.org/wiki/C++11

Core language features
1. auto and decltype
2. defaulted and deleted functions
  = default: use the compiler-generated version of that function, so you don't need to specify a body.
  move constructor isn't always generated by default. 
  default constructor does memberwise copy. it recursively copies/assigns based on what the members do. I.e. 
  it copies all the members of the class using their copy constructors. If those members have copy constructors that do a deep copy then you'll get a deep copy, 
  if they do a shallow copy then you'll get a shallow copy, or they could do something else entirely.
  
  = delete means to disable the usage of a member function
  The "delete" mechanism can be used for any function. For example, we can eliminate an undesired conversion like this:
  Deleting of special member functions provides a cleaner way of preventing the compiler from generating special member functions that we don’t want.
	struct Z {
		// ...

		Z(long long);     // can initialize with an long long
		Z(long) = delete; // but not anything less
	};

3. final and override
    override: Every time you define a method in the derived class that overrides a virtual method in the base class, you should tag it override
    (1). It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
    (2). The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

    final: This prevents any derived class of Derived to override the member function, or prevent the type to be inherited from.

3. trailing return type
   removes a C++ limitation where the return type of a function template cannot be generalized if the return type depends on the types of the function arguments.
   return auto type, for template case
   
4. rvalue references
An lvalue is an object which has its permanent memory location where they are stored (and not temporary objects and literals).
We can use the assignment operator to change the value of lvalue objects


an rvalue is a temporary object or a literal which doesn't have a permanent memory location. We cannot make assignments to rvalues
Rvalue references allow programmers to avoid logically unnecessary copying and to provide perfect forwarding functions
    Anything that is capable of returning a constant expression or value.
    Expression like a+b will return some constant.

An rvalue reference behaves just like an lvalue reference except that it can bind to a temporary (an rvalue), whereas you can not bind a (non const) lvalue reference to an rvalue.
    A&  a_ref3 = A();  // Error!
    A&& a_ref4 = A();  // Ok



5. move constructors and move assignment operators


6. scoped enums
7. constexpr and literal types
    Literals are the Constant values that are assigned to the constant variables.
    A constexpr function is one whose return value is computable at compile time when consuming code requires it.
    If you need guaranteed compile-time evaluation, use consteval instead. For constexpr compiler constants propagation is not guaranteed. 
    
    
    list initialization
    delegating and inherited constructors
    brace-or-equal initializers
    nullptr
    long long

char16_t and char32_t
    16-bit wide character used to store Unicode encoded as UTF-16LE
    
type aliases
    // type alias, identical to
    // typedef std::ios_base::fmtflags flags;
    using flags = std::ios_base::fmtflags;
    // the name 'flags' now denotes a type:
    flags fl = std::ios_base::dec;

    // type alias, identical to
    // typedef void (*func)(int, int);
    using func = void (*) (int, int);
    // the name 'func' now denotes a pointer to function:
    void example(int, int) {}
    func f = example;

    // alias template
    template<class T>
    using ptr = T*;
    // the name 'ptr<T>' is now an alias for pointer to T
    ptr<int> x;


    variadic templates
    generalized (non-trivial) unions
    generalized PODs (trivial types and standard-layout types)
    Unicode string literals
    user-defined literals
    attributes

lambda expressions:
    allow inline functions which can be used for short snippets of code that are not going to be reused and therefore do not require a name. 
    auto greet = []() {
      // lambda function body
    };
  
    auto greet =: defines a function pointer. 
    [] is called the lambda introducer which denotes the start of the lambda expression
    () is called the parameter list which is similar to the () operator of a normal function

    auto add = [] (int a, int b) {
     cout << "Sum = " << a + b;
    };
    
    auto add = [] (int a, int b) 
    { // The compiler can implicitly deduce the return type of the lambda expression based on the return statement(s).
      // always returns an 'int'
      return a + b;
    };
    
    auto operation = []  (int a, int b,  string op) -> double 
    {
        if (op == "sum") {
            // returns integer value
            return a + b;
        } 
        else {
            // returns double value
            return (a + b) / 2.0;
        }
    };
    
    C++ Lambda Function Capture Clause
    By default, lambda functions cannot access variables of the enclosing function. In order to access those variables, we use the capture clause.

    We can capture the variables in two ways:
    Capture by Value, Capture by Reference
    
    int num_main = 100;

    // get access to num_main from the enclosing function
    auto my_lambda = [num_main] () {
      cout << num_main;
    };
    
    // access the address of num_main variable
    auto my_lambda = [&num_main] () {
      num_main = 900;
    };
    
    
noexcept specifier and noexcept operator


alignof and alignas
    Alignment is a restriction on which memory positions a value's first byte can be stored. (It is needed to improve performance on processors and to permit use of certain instructions that works only on data with particular alignment, for example SSE need to be aligned to 16 bytes, while AVX to 32 bytes.)
    Alignment of 16 means that memory addresses that are a multiple of 16 are the only valid addresses.
    alignas: force alignment to the required number of bytes. You can only align to powers of 2: 1, 2, 4, 8, 16, 32, 64, 128, ...
        alignas(16) int a[4];
        alignas(1024) int b[4];
        printf("%p\n", a);
        printf("%p", b);
    alignof: Returns the alignment
        assert(alignof(a) == 16);
        assert(alignof(b) == 1024);


multithreaded memory model
thread-local storage


range-for (based on a Boost library)
    for ( auto address_entry : address_book )

static_assert (based on a Boost library) 
    Traditional assert means to end the execution of your program
    Static assertions are a way to check if a condition is true when the code is compiled

cast:
    static_cast: implicit conversions between types (such as int to float, or pointer to void*), and it can also call explicit conversion functions (or implicit ones).
    dynamic_cast: handling polymorphism: You can cast a pointer or reference to any polymorphic type to any other class type 
(a polymorphic type has at least one virtual function, declared or inherited). 
You can use it for more than just casting downwards – you can cast sideways or even up another chain.
    const_cast: remove or add const to a variable; no other C++ cast is capable of removing it
    reinterpret_cast
    (type)value (C-style cast)
    type(value) (function-style cast)
    difference: static_cast<> and C style casting
        char c = 65; //1-byte data. ASCII of ‘A’
        int *ptr = static_cast<int>(&c);
        This will generate compile time error.

Smart pointer:
    (1). auto_ptr: cannot be used in STL containers because it has a copy constructor that does not meet requirements of container CopyConstructible. 
unique_ptr does not implement a copy constructor, so containers use alternate methods. 
    (2). unique_ptr: at most one unique_ptr pointing at any one resource.
    (3). shared_ptr: wraps a reference counting mechanism around a raw pointer. 
    So for each instance of the shared_ptr the reference count is increased by one. 
    If two share_ptr objects refer the each other they will never get deleted because they will never end up with a reference count of zero.
    (4). weak_ptr: points to a shared_ptr but does not increase its reference count, it is not considered an owner. 
    This means that the underying object can still be deleted even though there is a weak_ptr reference to it.

        class A { shared_ptr<B> b; ... };
        class B { shared_ptr<A> a; ... };
        shared_ptr<A> x(new A);  // +1
        x->b = new B;            // +1
        x->b->a = x;             // +1
        // Ref count of 'x' is 2.
        // Ref count of 'x->b' is 1.
        // When 'x' leaves the scope, there will be a memory leak:
        // 2 is decremented to 1, and so both ref counts will be 1.
        // (Memory is deallocated only when ref count drops to 0)

Can weak_ptr be used in case the programmer cannot tell the ownership relationship and cannot establish any static ownership 
because of lack of privilege or lack of information? The answer is: If ownership among objects is unclear, weak_ptr cannot help. 
If there is a cycle, the programmer has to find it and break it. 
An alternative remedy is to use a programming language with full garbage collection (such as: Java, C#, Go, Haskell), 
or to use a conservative (=imperfect) garbage collector which works with C/C++ (such as: Boehm GC).
