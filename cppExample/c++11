https://www.stroustrup.com/C++11FAQ.html
https://en.wikipedia.org/wiki/C++11

Core language features
1. auto and decltype
2. defaulted and deleted functions
  = default: use the compiler-generated version of that function, so you don't need to specify a body.
  move constructor isn't always generated by default. 
  default constructor does memberwise copy. it recursively copies/assigns based on what the members do. I.e. 
  it copies all the members of the class using their copy constructors. If those members have copy constructors that do a deep copy then you'll get a deep copy, 
  if they do a shallow copy then you'll get a shallow copy, or they could do something else entirely.
  
  = delete means to disable the usage of a member function
  The "delete" mechanism can be used for any function. For example, we can eliminate an undesired conversion like this:
  Deleting of special member functions provides a cleaner way of preventing the compiler from generating special member functions that we donâ€™t want.
	struct Z {
		// ...

		Z(long long);     // can initialize with an long long
		Z(long) = delete; // but not anything less
	};

3. final and override
    override: Every time you define a method in the derived class that overrides a virtual method in the base class, you should tag it override
    (1). It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
    (2). The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

    final: This prevents any derived class of Derived to override the member function, or prevent the type to be inherited from.

3. trailing return type
   removes a C++ limitation where the return type of a function template cannot be generalized if the return type depends on the types of the function arguments.
   return auto type, for template case
   
4. rvalue references
5. move constructors and move assignment operators

6. scoped enums
7. constexpr and literal types
    Literals are the Constant values that are assigned to the constant variables.
    A constexpr function is one whose return value is computable at compile time when consuming code requires it.
    If you need guaranteed compile-time evaluation, use consteval instead. For constexpr compiler constants propagation is not guaranteed. 
    
    
    list initialization
    delegating and inherited constructors
    brace-or-equal initializers
    nullptr
    long long

char16_t and char32_t
    16-bit wide character used to store Unicode encoded as UTF-16LE
    
type aliases
    // type alias, identical to
    // typedef std::ios_base::fmtflags flags;
    using flags = std::ios_base::fmtflags;
    // the name 'flags' now denotes a type:
    flags fl = std::ios_base::dec;

    // type alias, identical to
    // typedef void (*func)(int, int);
    using func = void (*) (int, int);
    // the name 'func' now denotes a pointer to function:
    void example(int, int) {}
    func f = example;

    // alias template
    template<class T>
    using ptr = T*;
    // the name 'ptr<T>' is now an alias for pointer to T
    ptr<int> x;


    variadic templates
    generalized (non-trivial) unions
    generalized PODs (trivial types and standard-layout types)
    Unicode string literals
    user-defined literals
    attributes
    lambda expressions
    noexcept specifier and noexcept operator
    alignof and alignas
    multithreaded memory model
    thread-local storage
    GC interface (removed in C++23)
    range-for (based on a Boost library)
    static_assert (based on a Boost library) 

Smart pointer:
    (1). auto_ptr: cannot be used in STL containers because it has a copy constructor that does not meet requirements of container CopyConstructible. 
unique_ptr does not implement a copy constructor, so containers use alternate methods. 
    (2). unique_ptr: at most one unique_ptr pointing at any one resource.
    (3). shared_ptr: wraps a reference counting mechanism around a raw pointer. 
    So for each instance of the shared_ptr the reference count is increased by one. 
    If two share_ptr objects refer the each other they will never get deleted because they will never end up with a reference count of zero.
    (4). weak_ptr: points to a shared_ptr but does not increase its reference count, it is not considered an owner. 
    This means that the underying object can still be deleted even though there is a weak_ptr reference to it.

        class A { shared_ptr<B> b; ... };
        class B { shared_ptr<A> a; ... };
        shared_ptr<A> x(new A);  // +1
        x->b = new B;            // +1
        x->b->a = x;             // +1
        // Ref count of 'x' is 2.
        // Ref count of 'x->b' is 1.
        // When 'x' leaves the scope, there will be a memory leak:
        // 2 is decremented to 1, and so both ref counts will be 1.
        // (Memory is deallocated only when ref count drops to 0)

Can weak_ptr be used in case the programmer cannot tell the ownership relationship and cannot establish any static ownership 
because of lack of privilege or lack of information? The answer is: If ownership among objects is unclear, weak_ptr cannot help. 
If there is a cycle, the programmer has to find it and break it. 
An alternative remedy is to use a programming language with full garbage collection (such as: Java, C#, Go, Haskell), 
or to use a conservative (=imperfect) garbage collector which works with C/C++ (such as: Boehm GC).
