Copy and swap: used for copy-assignment operator. 
avoiding code duplication, and providing a strong exception guarantee.

1. the copy-constructor's functionality to create a local copy of the data (might fail)
2. destructor (should not fail)
3. swapping the old data with the new data (non-throwing function)

*****************************************************************************************************************************************************************************
# Padding
    Many processors expect memory for variables to be aligned based on the size of the variable. 
    the structure padding is automatically done by the compiler to make sure all its members are byte aligned.
    A ‘char’ of 1 byte can be allocated anywhere in memory like 0x5000 or 0x5001. 
    An ‘int’ of 4 bytes, must start at a 4-byte boundary like 0x5004 or 0x5008. 

*****************************************************************************************************************************************************************************
# Operator << Overloading, Operator >> Overloading

 	class Date
	{
	    int mo, da, yr;
	public:
	    friend ostream& operator<<(ostream& os, const Date& dt);
	    friend istream& operator>> (istream& is, Date& dt);
	};

	ostream& operator<<(ostream& os, const Date& dt)
	{
	    os << dt.mo << '/' << dt.da << '/' << dt.yr;
	    return os;
	}
	
	istream& operator>> (istream& is, Date& dt)
	{
	    is>> dt.mo>> dt.da>> dt.yr;
	    return is;
	}


    int main()
    {
        Date dt;
        cin >> dt;
        cout << dt;
    }

    Complex operator+(Complex const& obj)
    {
        Complex res;
        res.real = real + obj.real;
        res.imag = imag + obj.imag;
        return res;
    }

*****************************************************************************************************************************************************************************

# Bitfields: save space. They also allow an easier way to set values that aren't byte-aligned. 
    1. A special unnamed bit field of size 0 is used to force alignment on the next boundary
    2. We cannot have pointers to bit field members as they may not start at a byte boundary. 
    3. It is implementation-defined to assign an out-of-range value to a bit field member. 
    4. In C++, we can have static members in a structure/class, but bit fields cannot be static. 
    5. Array of bit fields is not allowed. For example, the below program fails in the compilation. 

    https://www.geeksforgeeks.org/bit-fields-c/


    struct
    {
        unsigned short icon : 8;
        unsigned short color : 4;
        unsigned short underline : 1;
        unsigned short blink : 1;
    } test1;
    
    struct mybitfields
    {
        unsigned short a : 4;
        unsigned short b : 5;
        unsigned short c : 7;
    } test2;
    
    struct
    {
        unsigned int first : 9;
        unsigned int second : 7;
        unsigned int may_straddle : 5;
        unsigned int last : 5;
    } test3;
    
    cout<< sizeof(test1) << sizeof(unsigned short) << endl;
    cout<< sizeof(test2) << endl;
    cout<< sizeof(test3) << endl;




*****************************************************************************************************************************************************************************

# Core language features
	https://www.stroustrup.com/C++11FAQ.html
	https://en.wikipedia.org/wiki/C++11

*****************************************************************************************************************************************************************************
# auto and decltype

decltype (compile time):
    If e is the name of a variable, i.e. an "id-expression", then the resulting type is the type of the variable.
    Otherwise, if e evaluates to an lvalue of type T, then the resulting type is T &, and if e evaluates to an rvalue of type T, then the resulting type is T.

	int var;
	const int&& fx();
	struct A { double x; }
	const A* a = new A();
	
	decltype(fx()); 	const int&& 	An rvalue reference to a const int.
	decltype(var); 		int 	The type of variable var.
	decltype(a->x); 	double 	The type of the member access.
	decltype((a->x)); 	const double& 	The inner parentheses cause the statement to be evaluated as an expression instead of a member access. 
	And because a is declared as a const pointer, the type is a reference to const double.

run-time type information(RTTI): exposes information about an object's data type at runtime
The typeid operator returns an lvalue of type const std::type_info that represents the type of expression expr
	const std::type_info& r1 = typeid(int);
	cout << r1.name();

typeid(x).name(): runtime
if we have a base class reference (or pointer) referring to (or pointing to) a derived class object, the decltype would give type as base class reference 
(or pointer, but typeid would give the derived type reference (or pointer).


*****************************************************************************************************************************************************************************
# default function and delete functions
  = default: use the compiler-generated version of that function, so you don't need to specify a body.
  move constructor isn't always generated by default. 
  default constructor does memberwise copy. it recursively copies/assigns based on what the members do. I.e. 
  it copies all the members of the class using their copy constructors. If those members have copy constructors that do a deep copy then you'll get a deep copy, 
  if they do a shallow copy then you'll get a shallow copy, or they could do something else entirely.
  
  = delete means to disable the usage of a member function
  The "delete" mechanism can be used for any function. For example, we can eliminate an undesired conversion like this:
  Deleting of special member functions provides a cleaner way of preventing the compiler from generating special member functions that we don’t want.
	struct Z {
		// ...

		Z(long long);     // can initialize with an long long
		Z(long) = delete; // but not anything less
	};

*****************************************************************************************************************************************************************************
3. final and override
    override: Every time you define a method in the derived class that overrides a virtual method in the base class, you should tag it override
    (1). It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
    (2). The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

    final: This prevents any derived class of Derived to override the member function, or prevent the type to be inherited from.
    	example:
   (1) struct B final : A
   (2) Function
           struct Base2 {
                virtual void f() final;
           };
*****************************************************************************************************************************************************************************

3. trailing return type: return type specified after the parameter list, following -> symbols:
       return type of a function template cannot be generalized if the return type depends on the types of the function arguments.

    example:
        auto HasMultipleItems() -> bool;
        auto Add(const TL& lhs, const TR& rhs) -> decltype(lhs + rhs)
        will not compile: decltype(lhs + rhs) Add(const TL& lhs, const TR& rhs). because where a return type is traditionally specified, those two formal parameters are not yet in scope

*****************************************************************************************************************************************************************************
4. rvalue references

    lvalue is an object which has its permanent memory location where they are stored (and not temporary objects and literals). 
	    We can use the assignment operator to change the value of lvalue objects
    rvalue is a temporary object or a literal which doesn't have a permanent memory location. 
        We cannot make assignments to rvalues
	    allow programmers to avoid logically unnecessary copying and to provide perfect forwarding functions
    	Anything that is capable of returning a constant expression or value.
    	Expression like a+b will return some constant.

    An rvalue reference behaves just like an lvalue reference except that it can bind to a temporary (an rvalue), 
    whereas you can not bind a (non const) lvalue reference to an rvalue.
        A&  a_ref3 = A();  // Error!
        A&& a_ref4 = A();  // Ok

    std::move() unconditionally cast argument to an rvalue, use move for rvalue reference.
    	template<typename T> 
    	decltype(auto) move(T && p)
    	{
    	  using returnType = remove_reference_t<T>&&;
    	  return static_cast<returnType>(param);
    	}
	
    std::forward<T>() perform conditional cast to an rvalue only if the argument is bound to an rvalue. 
    	function template taking a universal reference parameter, passed to another function.
    	Remove universal reference, and cast to rvalue
	
        	template <class T>
        	inline T&& forward(typename std::remove_reference<T>::type& t) noexcept
        	{
        	    return static_cast<T&&>(t);
        	}

        	template <class T>
        	inline T&& forward(typename std::remove_reference<T>::type&& t) noexcept
        	{
        		static_assert(!std::is_lvalue_reference<T>::value,
                    	  "Can not forward an rvalue as an lvalue.");
        		return static_cast<T&&>(t);
        	}
    
    Move requests on const object are treated as copy requests.  
    Move doesn't guarantee obj will be eligible to be moved. 
    	string(const string& rhs);
    	string(string && rhs);
    	
    	class Annotation
    	{
    		Annotation(const std::string text) : value(std::move(text))  -> goes to string copy constructor
    	}
    	
    universal reference(forwarding reference):
    	type T will be type deduction (template). 

*****************************************************************************************************************************************************************************
5. move constructors and move assignment operators
// Move constructor.
MemoryBlock(MemoryBlock&& other) noexcept
   : _data(nullptr)
   , _length(0)
{
   // Copy the data pointer and its length from the source object.
   _data = other._data;
   _length = other._length;

   // Release the data pointer from the source object so that
   // the destructor does not free the memory multiple times.
   other._data = nullptr;
   other._length = 0;
}

// Move assignment operator.
MemoryBlock& operator=(MemoryBlock&& other) noexcept
{
   if (this != &other)
   {
      // Free the existing resource.
      delete[] _data;

      // Copy the data pointer and its length from the source object.
      _data = other._data;
      _length = other._length;

      // Release the data pointer from the source object so that
      // the destructor does not free the memory multiple times.
      other._data = nullptr;
      other._length = 0;
   }
   return *this;
}

*****************************************************************************************************************************************************************************
6. scoped enums

*****************************************************************************************************************************************************************************
7. constexpr and literal types
    Literals are the Constant values that are assigned to the constant variables.
    A constexpr function is one whose return value is computable at compile time when consuming code requires it.
    If you need guaranteed compile-time evaluation, use consteval instead. For constexpr compiler constants propagation is not guaranteed. 

*****************************************************************************************************************************************************************************   
delegating and inherited constructors
    delegating constructors
        Many classes have multiple constructors that do similar things:  To add delegating constructors, use the constructor (. . .) : constructor (. . .) syntax:
    	class class_c {
    	public:
    	    int max;
    	    int min;
    	    int middle;
    	
    	    class_c(int my_max) {
    	        max = my_max > 0 ? my_max : 10;
    	    }
    	    class_c(int my_max, int my_min) : class_c(my_max) {
    	        min = my_min > 0 && my_min < max ? my_min : 1;
    	    }
    	    class_c(int my_max, int my_min, int my_middle) : class_c (my_max, my_min){
    	        middle = my_middle < max && my_middle > min ? my_middle : 5;
    	}
    	};
    
    inherited constructors
    if you have multiple constructors in Base and you want to support them all in the derived class. 
    A derived class can implicitly inherit constructors from its base class(es).
    
            struct B
            {
                B(int); // normal constructor 1
                B(string); // normal constructor 2
            };
            
            struct D : B
            {
                using B::B; // inherit constructors from B
            };


*****************************************************************************************************************************************************************************
brace-or-equal initializers, list initialization
    parentheses ()
    brace {}: can be used everywhere
    1. can't do implicit narrowing conversions among built in types. int sum(double a + double b)
    2. most vexing parse: widget w(10)  ctor or funciton
    3. if a ctor takes std::initializer_lists, then a call useing braced initializer will use this ctor. Even copy/move ctor can be hijacked by std::initializer_lists ctor.
	class Widget
	{
	   public:
	       widget(int i, bool b);
	       widget(std::initializer_list<long> il);
	}
	widget w{10, true} -> initializer_list ctor
	
*****************************************************************************************************************************************************************************
char16_t and char32_t
    16-bit wide character used to store Unicode encoded as UTF-16LE

*****************************************************************************************************************************************************************************
# type aliases
    "using" can do template, but typedef can't
    // typedef std::ios_base::fmtflags flags;
    using flags = std::ios_base::fmtflags;

    // type alias, identical to
    // typedef void (*func)(int, int);
    using func = void (*) (int, int);
    // the name 'func' now denotes a pointer to function:
    void example(int, int) {}
    func f = example;

    // alias template
    template<class T>
    using ptr = T*;
    // the name 'ptr<T>' is now an alias for pointer to T
    ptr<int> x;

*****************************************************************************************************************************************************************************

    variadic templates
    generalized (non-trivial) unions
    generalized PODs (trivial types and standard-layout types)
    Unicode string literals
    user-defined literals
    attributes

*****************************************************************************************************************************************************************************
std::enable_if: enable certain types for template specialization via some predicates known at the compile time. 
Using types that are not enabled by std::enable_if for template specialization will result in compile-time error.

template< bool B, class T = void >
struct enable_if;
If B is true, std::enable_if has a public member typedef type, equal to T; otherwise, there is no member typedef. 

template< bool B, class T = void >
using enable_if_t = typename enable_if<B,T>::type;

template<int a, int b, typename T = typename std::enable_if<a + b == 10>::type>
class foo {
};

template<typename T, typename std::enable_if_t<(sizeof(T) < sizeof(std::int32_t)), int> = 0>
constexpr bool less_than_int32()
{
  return true;
}

template<typename T, typename std::enable_if_t<(sizeof(T) >= sizeof(std::int32_t)), int> = 0>
constexpr bool less_than_int32()
{
  return false;
}

static_assert(less_than_int32<std::int16_t>());  // good: call first true
static_assert(less_than_int32<std::int64_t>());  // bad: call second one

*****************************************************************************************************************************************************************************
lambda expressions: allow inline functions which can be used for short snippets of code that are not going to be reused and therefore do not require a name. 
    auto greet = []() {
      // lambda function body
    };
  
    auto greet =: defines a function pointer. 
    []: capture clause(lambda introducer):  lambda functions cannot access variables of the enclosing function. 
    	In order to access those variables, we use the capture clause.
    () is called the parameter list which is similar to the () operator of a normal function
    [=] is shorthand for “capture all locals by value”
    [&] is shorthand for “capture all locals by reference”

    auto add = [] (int a, int b) 
    { // The compiler can implicitly deduce the return type of the lambda expression based on the return statement(s).
      // always returns an 'int'
      return a + b;
    };
    
    auto operation = []  (int a, int b,  string op) -> double 
    {
        if (op == "sum") {
            // returns integer value
            return a + b;
        } 
        else {
            // returns double value
            return (a + b) / 2.0;
        }
    };
    
    We can capture the variables in two ways: Capture by Value, Capture by Reference
    int num_main = 100;
    // get access to num_main from the enclosing function
    auto my_lambda = [num_main] () {
      cout << num_main;
    };   
    // access the address of num_main variable
    auto my_lambda = [&num_main] () {
      num_main = 900;
    };
    
    // pass lambda as argument
	#include <iostream>
	#include <functional>

	// call lambda by using template
	template <typename T>
	void print1(T adder, int a)
	{
	    std::cout << adder(a) << std::endl;
	}

	// call lambda by using std::function
	//void print2(std::function<int(int)> adder, int a)
	void print2(auto adder, int a)
	{
	    std::cout << adder(a) << std::endl;
	}

	int main()
	{
	    int num_main = 0;

	    auto my_lambda = [&num_main] (int a) {
	      num_main += a;
	      return num_main;
	    };

	    print1(my_lambda, 10);
	    print2(my_lambda, 10);
	    return 0;
	}

	#include <functional>
    std::function<int(int)> factorial = [&] (int i) 
    { 
        return (i == 1) ? 1 : i * factorial(i - 1); 
    };

*****************************************************************************************************************************************************************************

noexcept specifier and noexcept operator

*****************************************************************************************************************************************************************************

alignof and alignas
    Alignment is a restriction on which memory positions a value's first byte can be stored. (It is needed to improve performance on processors and to permit use of certain instructions that works only on data with particular alignment, for example SSE need to be aligned to 16 bytes, while AVX to 32 bytes.)
    Alignment of 16 means that memory addresses that are a multiple of 16 are the only valid addresses.
    alignas: force alignment to the required number of bytes. You can only align to powers of 2: 1, 2, 4, 8, 16, 32, 64, 128, ...
        alignas(16) int a[4];
        alignas(1024) int b[4];
        printf("%p\n", a);
        printf("%p", b);
    alignof: Returns the alignment
        assert(alignof(a) == 16);
        assert(alignof(b) == 1024);

*****************************************************************************************************************************************************************************

multithreaded memory model
thread-local storage

*****************************************************************************************************************************************************************************

range-for (based on a Boost library)
    for ( auto address_entry : address_book )

*****************************************************************************************************************************************************************************
static_assert (based on a Boost library) 
    Traditional assert means to end the execution of your program
    Static assertions are a way to check if a condition is true when the code is compiled

*****************************************************************************************************************************************************************************
cast:
    static_cast: no check, ordinary type conversion: like converting float to int, char to int,    
		int b = static_cast<int>(f)

    dynamic cast: used for handling polymorphism
    	downcast/upcasting: do casting between base and derived class pointer.
  	checks consistency at runtime; slower than static cast.
	The value of a failed cast to pointer type is the null pointer value of the required result type, no exception.
	If the cast fails and new_type is a reference type, it throws an exception: A failed cast to reference type throws std::bad_cast

    const_cast: add/remove const to a variable; no other C++ cast is capable of removing it
  	Modifying a formerly const value is undefined 
  	Remove const from objects in order to pass to non-const functions you know won't modify the argument.
	use to change non-const class members inside a const member function
	casting won’t happen if the type of cast is not same as original object // compiler error
    
    reinterpret_cast: dangerous, low level bit operations
    	convert raw data into actual data.
    
    (type)value (C-style cast)
    type(value) (function-style cast)
	    difference: static_cast<> and C style casting
        	char c = 65; //1-byte data. ASCII of ‘A’
        	int *ptr = static_cast<int>(&c);
        	This will generate compile time error.

*****************************************************************************************************************************************************************************
Smart pointer:
    1. auto_ptr: cannot be used in STL containers because it has a copy constructor that does not meet requirements of container CopyConstructible. 

    2. unique_ptr: smart pointer for exclusive ownership: at most one unique_ptr pointing at any one resource.
        advantage:
	(1). same size as raw pointer. 
        How to use:
	(2). move: transfer ownership, and source pointer is set to null.
        (3). copy: not allowed. unique_ptr does not implement a copy constructor, so containers use alternate methods. 
        (4). customer deleter: second template parameter, its deleter that has a default type std::default_delete<T> .
            auto log = [](int *p)
            {
              cout << "delete" << endl;
              delete p;
            };
            std::unique_ptr<int, decltype(log)> uniqueP(new int(5), log);
            std::shared_ptr<int> sharedP(new int(5), log);
        
        (5). two forms: unique_ptr<T>, unique_ptr<T[]>
        (6). can be converted to shared_ptr

    3. shared_ptr: smart pointer for shared ownership: more than one shared_ptr can pointing at the resource
        So for each instance of the shared_ptr the reference count is increased by one. 
        If two share_ptr objects refer the each other they will never get deleted because they will never end up with a reference count of zero. (cycle)
        (1). twice the size of raw pointer: wraps a reference counting mechanism around a raw pointer. 
            std::shared_ptr<T>
              ptr to T    ->    T object
              Ptr to control block    -> control block (reference count, weak count, custom deleter)
        (2). Control block: memory for the reference count should be dynamically allocated.
        (3). increments and decrements of the reference count must be atomic.
        (4). copying increment reference count, moving doesn't. 
        (5). self defined delete function
            auto log = [](int *p)
            {
              cout << "delete" << endl;
              delete p;
            };
            std::unique_ptr<int, decltype(log)> uniqueP(new int(5), log);
            std::shared_ptr<int> sharedP(new int(5), log);
        (6). When to create a control block: 
            make_shared<T>()
            when shared_ptr is constructed from unique_ptr.
            shared_ptr is called with raw pointer: more than one: destroyed multiple times, undifined program behavior
            avoid passing raw pointers to shared_ptr constructor, to use make_shared.
            if shared_ptr constructor should be used, try to use sharedptr rather than raw pointer
        (7). std::enable_shared_from_this: 
            base class template
            defines a member function crates a shared_ptr to the current obj, without duplicating coltrol block.
            looks up the control block for the current obj, and create shared_ptr based on it.

    4. weak_ptr: is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by std::shared_ptr.
        temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, 
        it must be converted to std::shared_ptr in order to access the referenced object.
        points to a shared_ptr but does not increase its reference count, it is not considered an owner (This means that the underying object can still be deleted even though there is a weak_ptr reference to it)
        Can't be dereferenced, can't be test for nullness. not standalone smart pointer, augmentation of shared_ptr.
        Created from shared_ptr, points to the same place, but don't affect the reference count. 
        If the original std::shared_ptr is destroyed at this time, the object's lifetime is extended until the temporary std::shared_ptr is destroyed as well.

        Usage:
            Can be used to check dangle pointer(wild pointer): cache, cycle. By just using raw pointers it is impossible to know if the referenced data has been deallocated or not. 
                (Instead, by letting a std::shared_ptr manage the data, and supplying std::weak_ptr to users of the data, can check whether the data is valid by calling expired() or lock())
            Break reference cycles formed by objects managed by std::shared_ptr. If such cycle is orphaned (i.e., there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. 
                To prevent this, one of the pointers in the cycle can be made weak.

        Can weak_ptr be used in case the programmer cannot tell the ownership relationship and cannot establish any static ownership 
        because of lack of privilege or lack of information? The answer is: If ownership among objects is unclear, weak_ptr cannot help. 
        If there is a cycle, the programmer has to find it and break it. 
        An alternative remedy is to use a programming language with full garbage collection (such as: Java, C#, Go, Haskell), 
        or to use a conservative (=imperfect) garbage collector which works with C/C++ (such as: Boehm GC).


        	test: weak_ptr.expired()
        	check expired, and return access to the obj:
        	    shared_ptr<Widget> sp = weakptr.lock(); // null if expired
        	    shared_ptr<Widget> sp(weakptr);  // throw exception
        	How to use:
        	  std::shared_ptr<int> sp (new int);
        	  std::weak_ptr<int> wp1;
        	  std::weak_ptr<int> wp2 (wp1);
        	  std::weak_ptr<int> wp3 (sp);

            class A { shared_ptr<B> b; ... };
            class B { shared_ptr<A> a; ... };
            shared_ptr<A> x(new A);  // +1
            x->b = new B;            // +1
            x->b->a = x;             // +1
            // Ref count of 'x' is 2.
            // Ref count of 'x->b' is 1.
            // When 'x' leaves the scope, there will be a memory leak:
            // 2 is decremented to 1, and so both ref counts will be 1.
            // (Memory is deallocated only when ref count drops to 0)
 
   5. make_unique<T>(), make_shared<T>() is better than shared_ptr<T> sp(new T)
    (1). only one allocation: single chunk of memory to hold both the object and control block. 
    (2). type T once
    (3). memory leak due to exception: two statement: new, run shared_ptr constructore.
    (4). Compiler may insert another statement or function call in between
    process(shared_ptr<widget>, int priority)
      no process(shared_ptr<T>(new T), computePriority())
      no shared_ptr<T> sp(new T, customDel)
         process(sp, computePriority())   performance: copy
      yes process(move(sp), computePriority())

    Not to use make_unique, make_shared:
    (1). custom delete. not supported
    (2). make function use perfect forwarding, parentheses, not braces. 
    using braced initialized, need to use new directly. 
    Or auto initList = {10, 20}
    auto spv = make_shared<vector<int>>(initList);
    (3). As long as weak_ptr refere to a control block, control block needs to exist. 
    The memory containing it should remain allocated. 
    If the obj is large and the time between destructio nof the last shared_ptr/week_ptr is significant, 
    a lag can occur between when an obj is freed and when memory occupied is freed.

***********************************************************************************************************
# Return value optimization: is a common form of copy elision. 
	It refers to the situation where an object returned by value from a method has its copy elided. 
	The example set forth in the standard illustrates named return value optimization, since the object is named.
	
	object is constructed from a temporary:  return T()

***********************************************************************************************************
std::ref, std::reference_wrapper
creates an object that behaves similarly to a reference

***********************************************************************************************************
small string optimization

	class string
	{
	  size_t capacity;
	
	  union
	  {
	    struct 
	    {
	      char *ptr;
	      size_t size;
	    } heapbuf;
	
	    char stackbuf[sizeof(heapbuf)];
	  };
	};

***********************************************************************************************************

template <class T>
class my_unique_ptr
{
private:
	T * ptr = nullptr;

public:
	my_unique_ptr() :  // default constructor
	{ ptr=nullptr; }

	my_unique_ptr(T * ptr)
	{ ptr = ptr; }

	my_unique_ptr(const my_unique_ptr & obj) = delete; // copy constructor is deleted
	my_unique_ptr& operator=(const my_unique_ptr & obj) = delete; // copy assignment is deleted

	my_unique_ptr(my_unique_ptr && dyingObj) // move constructor
	{
		// Transfer ownership of the memory pointed by dyingObj to this object
		this->ptr = dyingObj.ptr;
		dyingObj.ptr = nullptr; 
	}

	void operator=(my_unique_ptr && dyingObj) // move assignment
	{
		__cleanup__(); // cleanup any existing data

		// Transfer ownership of the memory pointed by dyingObj to this object
		this->ptr = dyingObj.ptr;
		dyingObj.ptr = nullptr;
	}

	T* operator->() // deferencing arrow operator
	{
		return this->ptr;
	}

	T& operator*()
	{
		return *(this->ptr);
	}

	~my_unique_ptr() // destructor
	{
		__cleanup__();
	}

private:
	void __cleanup__()
	{
		if (ptr != nullptr)
			delete ptr;
	}
};

template<class T>
class my_shared_ptr
{
private:
	T * ptr = nullptr;
	unsigned int * refCount = nullptr;	// should be pointer, so the value can be shared between different objects

public:
	my_shared_ptr() : ptr(nullptr), refCount(new unsigned int(0)) {} // default constructor
	my_shared_ptr(T * ptr) : ptr(ptr), refCount(new unsigned int(1))  {} // constructor

	my_shared_ptr(const my_shared_ptr & obj) // copy constructor
	{
		this->ptr = obj.ptr; // share the underlying pointer
		this->refCount = obj.refCount;
		if (nullptr != obj.ptr)
		{
			(*this->refCount)++; // if the pointer is not null, increment the refCount
		}
	}

	my_shared_ptr& operator=(const my_shared_ptr & obj) // copy assignment
	{
		__cleanup__(); // cleanup any existing data
		
		// Assign incoming object's data to this object
		this->ptr = obj.ptr; // share the underlying pointer
		this->refCount = obj.refCount;
		if (nullptr != obj.ptr)
		{
			(*this->refCount)++; // if the pointer is not null, increment the refCount
		}
	}

	/*** Move Semantics ***/
	my_shared_ptr(my_shared_ptr && dyingObj) // move constructor
	{
		this->ptr = dyingObj.ptr; // share the underlying pointer
		this->refCount = dyingObj.refCount;

		dyingObj.ptr = dyingObj.refCount = nullptr; // clean the dying object
	}

	my_shared_ptr& operator=(my_shared_ptr && dyingObj) // move assignment
	{
		__cleanup__(); // cleanup any existing data
		
		this->ptr = dyingObj.ptr; // share the underlying pointer
		this->refCount = dyingObj.refCount;

		dyingObj.ptr = dyingObj.refCount = nullptr; // clean the dying object
	}

	unsigned int get_count() const 
	{
		return *refCount; // *this->refCount
	}

	T* get() const { return this->ptr; }

	T* operator->() const
	{
		return this->ptr;
	}

	T& operator*() const
	{
		return this->ptr;
	}

	~my_shared_ptr() // destructor
	{
		__cleanup__();
	}

private:
	void __cleanup__()
	{
		(*refCount)--;
		if (*refCount == 0)
		{
			if (nullptr != ptr)
				delete ptr;
			delete refCount;
		}
	}
};

*****************************************************************************************************************************************************************************

placement new:
1. pointer you pass to the “placement new” operator points to a region of memory that is big enough 
2. is properly aligned for the object type that you’re creating

deletion: call destructor
only delete memeroy for new
    // buffer on stack
    unsigned char buf[sizeof(int)*2] ;
  
    // placement new in buf
    int *pInt = new (buf) int(3);
    int *qInt = new (buf + sizeof (int)) int(5);
    
  char memory[sizeof(Fred)]; // memory allocation
  void* p = memory;
  Fred* f = new(p) Fred();   // construct
  // ...
  f-       p->~T();
       }

       // deallocate storage p of deleted elements
       void deallocate (pointer p, size_type num) {
           // print message and deallocate memory with global delete
           std::cerr << "deallocate " << num << " element(s)"
                     << " of size " << sizeof(T)
                     << " at: " << (void*)p << std::endl;
           ::operator delete((void*)p);
       }
   };

std::construct_at:
Creates a T object initialized with arguments args... at given address p.
    S* ptr = std::construct_at(reinterpret_cast<S*>(storage), 42, 2.71828f, 3.1415);
    ptr->print(); 
    std::destroy_at(ptr);>~Fred();   // Explicitly call the destructor for the placed object

std::allocator is used to separate allocation and do construction in two steps, also separate destruction and deallocation
allocator is the memory allocator for the STL containers. 
a call of vec.reserve(n) of a vector vec allocates only memory for at least n elements. 
The constructor for each element will not be executed. also v.clear()
    allocator can be adjusted according to the container of your need, for example, vector where you only want to allocate occasionally.
    On the contrary, new doesn’t allow to have control over which constructors are called and simply construct all objects at the same time. 


    allocator<int> myAllocator;
    // allocate space for five ints
    int* arr = myAllocator.allocate(5);
 
    // construct arr[0] and arr[3]
    // myAllocator.construct(arr, 100); // no longer allowed in C++20
    arr[0] = 100; // do this instead
    arr[3] = 10;

    // deallocate space for five ints
    myAllocator.deallocate(arr, 5);    

implementation
	// allocate function uses the operator new function to allocate memory
	// The construct function uses placement-new to construct objects
       // allocate but don't initialize num elements of type T
       pointer allocate (size_type num, const void* = 0) {
           // print message and allocate memory with global new
           std::cerr << "allocate " << num << " element(s)"
                     << " of size " << sizeof(T) << std::endl;
           pointer ret = (pointer)(::operator new(num*sizeof(T)));
           std::cerr << " allocated at: " << (void*)ret << std::endl;
           return ret;
       }

       // initialize elements of allocated storage p with value value
       void construct (pointer p, const T& value) {
           // initialize memory with placement new
           new((void*)p)T(value);
       }

       // destroy elements of initialized storage p
       void destroy (pointer p) {
           // destroy objects by calling their destructor
           p->~T();
       }

       // deallocate storage p of deleted elements
       void deallocate (pointer p, size_type num) {
           // print message and deallocate memory with global delete
           std::cerr << "deallocate " << num << " element(s)"
                     << " of size " << sizeof(T)
                     << " at: " << (void*)p << std::endl;
           ::operator delete((void*)p);
       }
   };

std::construct_at:
Creates a T object initialized with arguments args... at given address p.
    S* ptr = std::construct_at(reinterpret_cast<S*>(storage), 42, 2.71828f, 3.1415);
    ptr->print(); 
    std::destroy_at(ptr);

https://codereview.stackexchange.com/questions/255149/stdvector-allocator-aware-implementation
#include <iostream>

using namespace std;

template<typename T>
class myVector
{
public:
    myVector()
    {
        _capacity = 2;
        _data = _a.allocate(_capacity);
    }    
    myVector(int n)
    {
        _data = _a.allocate(n);
        _capacity = n;
    }
    
    myVector(int n, const T& e)
    {
        _data = allocator_traits<allocator<T>>::allocate(_a, n);
        for(size_t i=0; i<n; i++)
            allocator_traits<allocator<T>>::construct(_a, _data+i, e);
        _size = _capacity = n;
    }
    
    myVector(const myVector& v)
    {
        _size = v._size;
        _capacity = v._capacity;

        if(v._data == nullptr)
            _data = nullptr;
        else
        {
            _data = allocator_traits<allocator<T>>::allocate(_a, _capacity);
            for(size_t i=0; i<_size; i++)
                allocator_traits<allocator<T>>::construct(_a, _data+i, *(v._data+i));
        }
    }
    
    myVector(myVector<T>&& v)
    {
        _data = v._data;
        _size = v._size;
        _capacity = v._capacity;
        _a = move(v._a);
        
        v._data = nullptr;
        v._size = 0;
        v._capacity = 0;
    }

        myVector& operator=(const vector& other) 
        {
            if (this == &other) 
                return *this;
            
            for (size_t i=0; i < _size; ++i)
                allocator_traits<allocator<T>>::destroy(_a, _data + i);
                
            if (other._data)
            {
                if (other.size() > _capacity) 
                {
                    allocator_traits<allocator<T>>::deallocate(_a, _data, _capacity);
                                
                    _capacity = other;
                    _data = allocator_traits<allocator<T>>::allocate(_a, _capacity);
                }
                
                _size = other._size;
                for (size_t i=0; i < _size; ++i) {
                    allocator_traits<allocator<T>>::construct(_a, _data + i, *(other._data + i));

            }
            else 
            {
                _data = nullptr;
                _size = 0;
            }
            return *this;
        }
        
        
        constexpr vector& operator=(vector&& other) noexcept 
        {
            if (this == &other) { return *this; }

            if constexpr (std::allocator_traits<allocator_type>::propagate_on_container_move_assignment::value) {
                deallocate_and_destruct(capacity(), size());
                m_allocator = other.get_allocator();
                m_vector = other.m_vector;
                reset(other);
            }
            else if (m_allocator == other.m_allocator) {
                deallocate_and_destruct(capacity(), size());
                m_vector = other.m_vector;
                reset(other);
            }
            else {
                destruct(size());
                reallocate(capacity(), other.capacity());
                            m_size = other.m_size;
            m_capacity = other.m_capacity;
            for (size_type index{ 0 }; index < m_size; ++index)
                allocator_traits<allocator_type>::construct(m_allocator, m_vector + index, std::move(*(other.m_vector + index)));
                
                uninitialized_alloc_move(std::move(other));
            }
            
            _size = other._size;
            _capacity = other._capacity;

            return *this;
        }
	
    ~myVector()
    {
        for (std::size_t i = 0; i < _size; ++i)
            allocator_traits<allocator<T>>::destroy(_a, _data + i);
        allocator_traits<allocator<T>>::deallocate(_a, _data, _capacity);
        _size = _capacity = 0;
        _data = nullptr;
    }
    
    T& operator[] (size_t i)
    {
        return _data[i];
    }

    // when move-construction could raise an exception, so if the value type's move-ctor is not exception safe, std::vector push_back() needs to use to the copy operation instead during size*2. 
    // 
    	template<class T>
	void Fwd(T &&v) { Call(std::forward<T>(v)); }

    // perfect forwarding
    // reference collapsing rules (save for A& & -> A&, which is C++98/03) exist for one reason: to allow  to work.
	// "Perfect" forwarding means to effectively forward parameters as if the user had called the function directly (minus elision, which is broken by forwarding). 
	// by value, by (possibly const) lvalue reference, and by (possibly const) rvalue reference.

    template<typename U>
    void push_back(U&& e)
    {
        bool moveNothrow = std::is_nothrow_move_constructible<Type>::value;
        // || (!std::is_nothrow_move_constructible<Type>::value && !std::is_copy_constructible<Type>::value)
        // or: nothrow move ctor, and no copy ctor

        if(_size < _capacity)
        {
            if(moveNoThrow)
            {
                allocator_traits<allocator<T>>::construct(_a, _data+_size, forward<U>(e));
                _size ++;
            }
            else
            {
                try
                {
                    allocator_traits<allocator<T>>::construct(_a, _data+_size, forward<U>(e));
                }
                catch(...)
                {
                    allocator_traits<allocator<T>>::destroy(_a, _data+_size);
                    throw;
                }
                _size ++;

            }
        }
        else
        {
            T* temp = allocator_traits<allocator<T>>::allocate(_a, _capacity*2);
            if(moveNothrow)
            {
                for(size_t i=0; i<_size; i++)
                    allocator_traits<allocator<T>>::construct(_a, temp+i, forward<T>(_data[i])); // move ctor                    
            }
            else
            {
                size_t success = 0;
                try
                {
                    for(size_t i=0; i<_size; i++)
                    {
                        allocator_traits<allocator<T>>::construct(_a, temp+i, _data[i]); // copy ctor
                        success++;
                    }
                }
                catch(...)
                {
                    for (size_t i=0; i < success; ++i)
                        allocator_traits<allocator_type>::destroy(_a, temp + i);
                    std::allocator_traits<allocator_type>::deallocate(m_allocator, temp, capacity);

                    throw;
                }
            }
            
            _data = temp;
            _size ++;
            _capacity *= 2;
        }           
    }
    
    inline size_t size() { return _size; }
    
	private:
	    size_t _size = 0;
	    size_t _capacity = 2;
	    T* _data = nullptr;
	    allocator<T> _a;
	};
	
	int main()
	{
	    
	    myVector<string> v;
	    v.push_back(move("h1"));
	    string s = "h2";
	    v.push_back(s);
	    v.push_back("h3");
	    v.push_back("h4");
	    
	    
	    /*
	    myVector<int> v;
	    v.push_back(1);
	    v.push_back(2);
	    v.push_back(3);
	    v.push_back(4);    */
	    myVector<string> v2(v);
	     for(size_t i=0; i<v2.size(); i++)
	        cout << i << v2[i] << endl;
	        
	    
	    return 0;
	}

***************************************************************************************************************************************************************************** 

