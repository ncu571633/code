Padding:
Many processors expect memory for variables to be aligned based on the size of the variable. 
the structure padding is automatically done by the compiler to make sure all its members are byte aligned.
A ‘char’ of 1 byte can be allocated anywhere in memory like 0x5000 or 0x5001. 
An ‘int’ of 4 bytes, must start at a 4-byte boundary like 0x5004 or 0x5008. T

Overload
#include <iostream>
using namespace std;

class Date
{
    int mo, da, yr;
public:
    friend ostream& operator<<(ostream& os, const Date& dt);
    friend istream& operator>> (istream& is, Date& dt);
};

ostream& operator<<(ostream& os, const Date& dt)
{
    os << dt.mo << '/' << dt.da << '/' << dt.yr;
    return os;
}

istream& operator>> (istream& is, Date& dt)
{
    is>> dt.mo>> dt.da>> dt.yr;
    return is;
}


int main()
{
    Date dt;
    cin >> dt;
    cout << dt;
}

    Complex operator+(Complex const& obj)
    {
        Complex res;
        res.real = real + obj.real;
        res.imag = imag + obj.imag;
        return res;
    }



Bitfields: save space. They also allow an easier way to set values that aren't byte-aligned. 
1. A special unnamed bit field of size 0 is used to force alignment on the next boundary
2. We cannot have pointers to bit field members as they may not start at a byte boundary. 
3. It is implementation-defined to assign an out-of-range value to a bit field member. 
4. In C++, we can have static members in a structure/class, but bit fields cannot be static. 
5. Array of bit fields is not allowed. For example, the below program fails in the compilation. 

https://www.geeksforgeeks.org/bit-fields-c/


struct
{
    unsigned short icon : 8;
    unsigned short color : 4;
    unsigned short underline : 1;
    unsigned short blink : 1;
} test1;

struct mybitfields
{
    unsigned short a : 4;
    unsigned short b : 5;
    unsigned short c : 7;
} test2;

struct
{
    unsigned int first : 9;
    unsigned int second : 7;
    unsigned int may_straddle : 5;
    unsigned int last : 5;
} test3;

cout<< sizeof(test1) << sizeof(unsigned short) << endl;
cout<< sizeof(test2) << endl;
cout<< sizeof(test3) << endl;


https://www.stroustrup.com/C++11FAQ.html
https://en.wikipedia.org/wiki/C++11

Core language features

*****************************************************************************************************************************************************************************
1. auto and decltype

decltype:
    If e is the name of a variable, i.e. an "id-expression", then the resulting type is the type of the variable.
    Otherwise, if e evaluates to an lvalue of type T, then the resulting type is T &, and if e evaluates to an rvalue of type T, then the resulting type is T.

int var;
const int&& fx();
struct A { double x; }
const A* a = new A();

decltype(fx()); 	const int&& 	An rvalue reference to a const int.
decltype(var); 	int 	The type of variable var.
decltype(a->x); 	double 	The type of the member access.
decltype((a->x)); 	const double& 	The inner parentheses cause the statement to be evaluated as an expression instead of a member access. 
And because a is declared as a const pointer, the type is a reference to const double.

*****************************************************************************************************************************************************************************
2. defaulted and deleted functions
  = default: use the compiler-generated version of that function, so you don't need to specify a body.
  move constructor isn't always generated by default. 
  default constructor does memberwise copy. it recursively copies/assigns based on what the members do. I.e. 
  it copies all the members of the class using their copy constructors. If those members have copy constructors that do a deep copy then you'll get a deep copy, 
  if they do a shallow copy then you'll get a shallow copy, or they could do something else entirely.
  
  = delete means to disable the usage of a member function
  The "delete" mechanism can be used for any function. For example, we can eliminate an undesired conversion like this:
  Deleting of special member functions provides a cleaner way of preventing the compiler from generating special member functions that we don’t want.
	struct Z {
		// ...

		Z(long long);     // can initialize with an long long
		Z(long) = delete; // but not anything less
	};
*****************************************************************************************************************************************************************************
3. final and override
    override: Every time you define a method in the derived class that overrides a virtual method in the base class, you should tag it override
    (1). It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
    (2). The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

    final: This prevents any derived class of Derived to override the member function, or prevent the type to be inherited from.
    
*****************************************************************************************************************************************************************************
3. trailing return type
   removes a C++ limitation where the return type of a function template cannot be generalized if the return type depends on the types of the function arguments.
   return auto type, for template case

*****************************************************************************************************************************************************************************
4. rvalue references
  lvalue is an object which has its permanent memory location where they are stored (and not temporary objects and literals).
	We can use the assignment operator to change the value of lvalue objects
  rvalue is a temporary object or a literal which doesn't have a permanent memory location. We cannot make assignments to rvalues
	Rvalue references allow programmers to avoid logically unnecessary copying and to provide perfect forwarding functions
    	Anything that is capable of returning a constant expression or value.
    	Expression like a+b will return some constant.

An rvalue reference behaves just like an lvalue reference except that it can bind to a temporary (an rvalue), 
whereas you can not bind a (non const) lvalue reference to an rvalue.
    A&  a_ref3 = A();  // Error!
    A&& a_ref4 = A();  // Ok

std::move() unconditionally cast argument to an rvalue, use move for rvalue reference.
	template<typename T> 
	decltype(auto) move(T && p)
	{
	  using returnType = remove_reference_t<T>&&;
	  return static_cast<returnType>(param);
	}
	
std::forward<T>() perform conditional cast to an rvalue only if the argument is bound to an rvalue. 
	function template taking a universal reference parameter, passed to another function.
	Remove universal reference, and cast to rvalue
	
	template <class T>
	inline T&& forward(typename std::remove_reference<T>::type& t) noexcept
	{
	    return static_cast<T&&>(t);
	}

	template <class T>
	inline T&& forward(typename std::remove_reference<T>::type&& t) noexcept
	{
    		static_assert(!std::is_lvalue_reference<T>::value,
                	  "Can not forward an rvalue as an lvalue.");
    		return static_cast<T&&>(t);
    	}
    
Move requests on const object are treated as copy requests.  
Move doesn't guarantee obj will be eligible to be moved. 
	string(const string& rhs);
	string(string && rhs);
	
	class Annotation
	{
		Annotation(const std::string text) : value(std::move(text))  -> goes to string copy constructor
	}
	
universal reference(forwarding reference):
	type T will be type deduction (template). 

*****************************************************************************************************************************************************************************
5. move constructors and move assignment operators
// Move constructor.
MemoryBlock(MemoryBlock&& other) noexcept
   : _data(nullptr)
   , _length(0)
{
   // Copy the data pointer and its length from the source object.
   _data = other._data;
   _length = other._length;

   // Release the data pointer from the source object so that
   // the destructor does not free the memory multiple times.
   other._data = nullptr;
   other._length = 0;
}

// Move assignment operator.
MemoryBlock& operator=(MemoryBlock&& other) noexcept
{
   if (this != &other)
   {
      // Free the existing resource.
      delete[] _data;

      // Copy the data pointer and its length from the
      // source object.
      _data = other._data;
      _length = other._length;

      // Release the data pointer from the source object so that
      // the destructor does not free the memory multiple times.
      other._data = nullptr;
      other._length = 0;
   }
   return *this;
}

*****************************************************************************************************************************************************************************
6. scoped enums

*****************************************************************************************************************************************************************************
7. constexpr and literal types
    Literals are the Constant values that are assigned to the constant variables.
    A constexpr function is one whose return value is computable at compile time when consuming code requires it.
    If you need guaranteed compile-time evaluation, use consteval instead. For constexpr compiler constants propagation is not guaranteed. 

*****************************************************************************************************************************************************************************   
delegating and inherited constructors
delegating constructors
    Many classes have multiple constructors that do similar things:  To add delegating constructors, use the constructor (. . .) : constructor (. . .) syntax:
	class class_c {
	public:
	    int max;
	    int min;
	    int middle;
	
	    class_c(int my_max) {
	        max = my_max > 0 ? my_max : 10;
	    }
	    class_c(int my_max, int my_min) : class_c(my_max) {
	        min = my_min > 0 && my_min < max ? my_min : 1;
	    }
	    class_c(int my_max, int my_min, int my_middle) : class_c (my_max, my_min){
	        middle = my_middle < max && my_middle > min ? my_middle : 5;
	}
	};

inherited constructors
if you have multiple constructors in Base and you want to support them all in the derived class. 
A derived class can implicitly inherit constructors from its base class(es).

        struct B
        {
            B(int); // normal constructor 1
            B(string); // normal constructor 2
        };
        
        struct D : B
        {
            using B::B; // inherit constructors from B
        };


*****************************************************************************************************************************************************************************
brace-or-equal initializers, list initialization
    parentheses ()
    brace {}: can be used everywhere
    1. can't do implicit narrowing conversions among built in types. int sum(double a + double b)
    2. most vexing parse: widget w(10)  ctor or funciton
    3. if a ctor takes std::initializer_lists, then a call useing braced initializer will use this ctor. Even copy/move ctor can be hijacked by std::initializer_lists ctor.
	class Widget
	{
	   public:
	       widget(int i, bool b);
	       widget(std::initializer_list<long> il);
	}
	widget w{10, true} -> initializer_list ctor
	
*****************************************************************************************************************************************************************************
char16_t and char32_t
    16-bit wide character used to store Unicode encoded as UTF-16LE

*****************************************************************************************************************************************************************************
type aliases
    // type alias, identical to
    // typedef std::ios_base::fmtflags flags;
    using flags = std::ios_base::fmtflags;
    // the name 'flags' now denotes a type:
    flags fl = std::ios_base::dec;

    // type alias, identical to
    // typedef void (*func)(int, int);
    using func = void (*) (int, int);
    // the name 'func' now denotes a pointer to function:
    void example(int, int) {}
    func f = example;

    // alias template
    template<class T>
    using ptr = T*;
    // the name 'ptr<T>' is now an alias for pointer to T
    ptr<int> x;

*****************************************************************************************************************************************************************************

    variadic templates
    generalized (non-trivial) unions
    generalized PODs (trivial types and standard-layout types)
    Unicode string literals
    user-defined literals
    attributes
*****************************************************************************************************************************************************************************
std::enable_if: enable certain types for template specialization via some predicates known at the compile time. 
Using types that are not enabled by std::enable_if for template specialization will result in compile-time error.

template< bool B, class T = void >
struct enable_if;
If B is true, std::enable_if has a public member typedef type, equal to T; otherwise, there is no member typedef. 

template< bool B, class T = void >
using enable_if_t = typename enable_if<B,T>::type;

template<int a, int b, typename T = typename std::enable_if<a + b == 10>::type>
class foo {
};

template<typename T, typename std::enable_if_t<(sizeof(T) < sizeof(std::int32_t)), int> = 0>
constexpr bool less_than_int32()
{
  return true;
}

template<typename T, typename std::enable_if_t<(sizeof(T) >= sizeof(std::int32_t)), int> = 0>
constexpr bool less_than_int32()
{
  return false;
}

static_assert(less_than_int32<std::int16_t>());  // good: call first true
static_assert(less_than_int32<std::int64_t>());  // bad: call second one

*****************************************************************************************************************************************************************************
lambda expressions: allow inline functions which can be used for short snippets of code that are not going to be reused and therefore do not require a name. 
    auto greet = []() {
      // lambda function body
    };
  
    auto greet =: defines a function pointer. 
    []: capture clause(lambda introducer):  lambda functions cannot access variables of the enclosing function. 
    	In order to access those variables, we use the capture clause.
    () is called the parameter list which is similar to the () operator of a normal function
  
    auto add = [] (int a, int b) 
    { // The compiler can implicitly deduce the return type of the lambda expression based on the return statement(s).
      // always returns an 'int'
      return a + b;
    };
    
    auto operation = []  (int a, int b,  string op) -> double 
    {
        if (op == "sum") {
            // returns integer value
            return a + b;
        } 
        else {
            // returns double value
            return (a + b) / 2.0;
        }
    };
    
    We can capture the variables in two ways: Capture by Value, Capture by Reference
    int num_main = 100;
    // get access to num_main from the enclosing function
    auto my_lambda = [num_main] () {
      cout << num_main;
    };   
    // access the address of num_main variable
    auto my_lambda = [&num_main] () {
      num_main = 900;
    };
    
    // pass lambda as argument
	#include <iostream>
	#include <functional>

	// call lambda by using template
	template <typename T>
	void print1(T adder, int a)
	{
	    std::cout << adder(a) << std::endl;
	}

	// call lambda by using std::function
	//void print2(std::function<int(int)> adder, int a)
	void print2(auto adder, int a)
	{
	    std::cout << adder(a) << std::endl;
	}

	int main()
	{
	    int num_main = 0;

	    auto my_lambda = [&num_main] (int a) {
	      num_main += a;
	      return num_main;
	    };

	    print1(my_lambda, 10);
	    print2(my_lambda, 10);
	    return 0;
	}


*****************************************************************************************************************************************************************************

noexcept specifier and noexcept operator

*****************************************************************************************************************************************************************************

alignof and alignas
    Alignment is a restriction on which memory positions a value's first byte can be stored. (It is needed to improve performance on processors and to permit use of certain instructions that works only on data with particular alignment, for example SSE need to be aligned to 16 bytes, while AVX to 32 bytes.)
    Alignment of 16 means that memory addresses that are a multiple of 16 are the only valid addresses.
    alignas: force alignment to the required number of bytes. You can only align to powers of 2: 1, 2, 4, 8, 16, 32, 64, 128, ...
        alignas(16) int a[4];
        alignas(1024) int b[4];
        printf("%p\n", a);
        printf("%p", b);
    alignof: Returns the alignment
        assert(alignof(a) == 16);
        assert(alignof(b) == 1024);

*****************************************************************************************************************************************************************************

multithreaded memory model
thread-local storage

*****************************************************************************************************************************************************************************

range-for (based on a Boost library)
    for ( auto address_entry : address_book )

*****************************************************************************************************************************************************************************
static_assert (based on a Boost library) 
    Traditional assert means to end the execution of your program
    Static assertions are a way to check if a condition is true when the code is compiled

*****************************************************************************************************************************************************************************
cast:
    static_cast: no check, ordinary type conversion: like converting float to int, char to int,    
    dynamic cast: used for handling polymorphism
    	downcast/upcasting: do casting between base and derived class pointer.
  	checks consistency at runtime; slower than static cast.
	The value of a failed cast to pointer type is the null pointer value of the required result type, no exception.
	If the cast fails and new_type is a reference type, it throws an exception: A failed cast to reference type throws std::bad_cast
    const_cast: add/remove const to a variable; no other C++ cast is capable of removing it
  	Modifying a formerly const value is undefined 
  	Remove const from objects in order to pass to non-const functions you know won't modify the argument.
	use to change non-const class members inside a const member function
	casting won’t happen if the type of cast is not same as original object // compiler error
    reinterpret_cast: dangerous, low level bit operations
    	convert raw data into actual data.
    (type)value (C-style cast)
    type(value) (function-style cast)
	    difference: static_cast<> and C style casting
        	char c = 65; //1-byte data. ASCII of ‘A’
        	int *ptr = static_cast<int>(&c);
        	This will generate compile time error.
	

*****************************************************************************************************************************************************************************
Smart pointer:
    (1). auto_ptr: cannot be used in STL containers because it has a copy constructor that does not meet requirements of container CopyConstructible. 
unique_ptr does not implement a copy constructor, so containers use alternate methods. 
    (2). unique_ptr: at most one unique_ptr pointing at any one resource.
    (3). shared_ptr: wraps a reference counting mechanism around a raw pointer. 
    So for each instance of the shared_ptr the reference count is increased by one. 
    If two share_ptr objects refer the each other they will never get deleted because they will never end up with a reference count of zero.
    (4). weak_ptr: points to a shared_ptr but does not increase its reference count, it is not considered an owner. 
    This means that the underying object can still be deleted even though there is a weak_ptr reference to it.

        class A { shared_ptr<B> b; ... };
        class B { shared_ptr<A> a; ... };
        shared_ptr<A> x(new A);  // +1
        x->b = new B;            // +1
        x->b->a = x;             // +1
        // Ref count of 'x' is 2.
        // Ref count of 'x->b' is 1.
        // When 'x' leaves the scope, there will be a memory leak:
        // 2 is decremented to 1, and so both ref counts will be 1.
        // (Memory is deallocated only when ref count drops to 0)

Can weak_ptr be used in case the programmer cannot tell the ownership relationship and cannot establish any static ownership 
because of lack of privilege or lack of information? The answer is: If ownership among objects is unclear, weak_ptr cannot help. 
If there is a cycle, the programmer has to find it and break it. 
An alternative remedy is to use a programming language with full garbage collection (such as: Java, C#, Go, Haskell), 
or to use a conservative (=imperfect) garbage collector which works with C/C++ (such as: Boehm GC).

unique_ptr: exclusive ownership 
2. same size as raw pointer. 
3. move: transfer ownership, and seource pointer is set to null.
4. copy: not allowed
5. customer deleter: second template parameter, its deleter that has a default type std::default_delete<T> .
    auto log = [](int *p)
    {
      cout << "delete" << endl;
      delete p;
    };
    std::unique_ptr<int, decltype(log)> uniqueP(new int(5), log);
    std::shared_ptr<int> sharedP(new int(5), log);
    
6. two forms: unique_ptr<T>, unique_ptr<T[]>
7. can be converted to shared_ptr


template <class T>
class my_unique_ptr
{
private:
	T * ptr = nullptr;

public:
	my_unique_ptr() :  // default constructor
	{ ptr=nullptr; }

	my_unique_ptr(T * ptr)
	{ ptr = ptr; }

	my_unique_ptr(const my_unique_ptr & obj) = delete; // copy constructor is deleted
	my_unique_ptr& operator=(const my_unique_ptr & obj) = delete; // copy assignment is deleted

	my_unique_ptr(my_unique_ptr && dyingObj) // move constructor
	{
		// Transfer ownership of the memory pointed by dyingObj to this object
		this->ptr = dyingObj.ptr;
		dyingObj.ptr = nullptr; 
	}

	void operator=(my_unique_ptr && dyingObj) // move assignment
	{
		__cleanup__(); // cleanup any existing data

		// Transfer ownership of the memory pointed by dyingObj to this object
		this->ptr = dyingObj.ptr;
		dyingObj.ptr = nullptr;
	}

	T* operator->() // deferencing arrow operator
	{
		return this->ptr;
	}

	T& operator*()
	{
		return *(this->ptr);
	}

	~my_unique_ptr() // destructor
	{
		__cleanup__();
	}

private:
	void __cleanup__()
	{
		if (ptr != nullptr)
			delete ptr;
	}
};

shared_ptr: shared ownership
1. twice the size of raw pointer
2. memory for the reference count should be dynamically allocated.
3. increments and decrements of the reference count must be atomic.
4. copying increment reference count, moving doesn't. 
5. 
    auto log = [](int *p)
    {
      cout << "delete" << endl;
      delete p;
    };
    std::unique_ptr<int, decltype(log)> uniqueP(new int(5), log);
    std::shared_ptr<int> sharedP(new int(5), log);
6. std::shared_ptr<T>
  ptr to T    ->    T object
  Ptr to control block    -> control block (reference count, weak count, custom deleter)
7. When to create a control block: 
    make_shared<T>()
    when shared_ptr is constructed from unique_ptr.
    shared_ptr is called with raw pointer: more than one: destroyed multiple times, undifined program behavior
    avoid passing raw pointers to shared_ptr constructor, to use make_shared.
    if shared_ptr constructor should be used, try to use sharedptr rather than raw pointer
8. std::enable_shared_from_this: 
    base class template
    defines a member function crates a shared_ptr to the current obj, without duplicating coltrol block.
    looks up the control block for the current obj, and create shared_ptr based on it.
    
    
template<class T>
class my_shared_ptr
{
private:
	T * ptr = nullptr;
	unsigned int * refCount = nullptr;	// should be pointer, so the value can be shared between different objects

public:
	my_shared_ptr() : ptr(nullptr), refCount(new unsigned int(0)) {} // default constructor
	my_shared_ptr(T * ptr) : ptr(ptr), refCount(new unsigned int(1))  {} // constructor

	my_shared_ptr(const my_shared_ptr & obj) // copy constructor
	{
		this->ptr = obj.ptr; // share the underlying pointer
		this->refCount = obj.refCount;
		if (nullptr != obj.ptr)
		{
			(*this->refCount)++; // if the pointer is not null, increment the refCount
		}
	}

	my_shared_ptr& operator=(const my_shared_ptr & obj) // copy assignment
	{
		__cleanup__(); // cleanup any existing data
		
		// Assign incoming object's data to this object
		this->ptr = obj.ptr; // share the underlying pointer
		this->refCount = obj.refCount;
		if (nullptr != obj.ptr)
		{
			(*this->refCount)++; // if the pointer is not null, increment the refCount
		}
	}

	/*** Move Semantics ***/
	my_shared_ptr(my_shared_ptr && dyingObj) // move constructor
	{
		this->ptr = dyingObj.ptr; // share the underlying pointer
		this->refCount = dyingObj.refCount;

		dyingObj.ptr = dyingObj.refCount = nullptr; // clean the dying object
	}

	my_shared_ptr& operator=(my_shared_ptr && dyingObj) // move assignment
	{
		__cleanup__(); // cleanup any existing data
		
		this->ptr = dyingObj.ptr; // share the underlying pointer
		this->refCount = dyingObj.refCount;

		dyingObj.ptr = dyingObj.refCount = nullptr; // clean the dying object
	}

	unsigned int get_count() const 
	{
		return *refCount; // *this->refCount
	}

	T* get() const { return this->ptr; }

	T* operator->() const
	{
		return this->ptr;
	}

	T& operator*() const
	{
		return this->ptr;
	}

	~my_shared_ptr() // destructor
	{
		__cleanup__();
	}

private:
	void __cleanup__()
	{
		(*refCount)--;
		if (*refCount == 0)
		{
			if (nullptr != ptr)
				delete ptr;
			delete refCount;
		}
	}
};

weak_ptr: can't be dereferenced, can't be test for nullness. not standalone smart pointer, augmentation of shared_ptr. can be used to check dangle pointer(wild pointer): cache, cycle. 
created from shared_ptr, points to the same place, but don't affect the reference count. 
test: weak_ptr.expired()
check expired, and return access to the obj:
    shared_ptr<Widget> sp = weakptr.lock(); // null if expired
    shared_ptr<Widget> sp(weakptr);  // throw exception
How to use:
  std::shared_ptr<int> sp (new int);
  std::weak_ptr<int> wp1;
  std::weak_ptr<int> wp2 (wp1);
  std::weak_ptr<int> wp3 (sp);
  
make_unique<T>(), make_shared<T>() is better than shared_ptr<T> sp(new T)
1. only one allocation: single chunk of memory to hold both the object and control block. 
2. type T once
3. memory leak due to exception: two statement: new, run shared_ptr constructore.
Compiler may insert another statement or function call in between
process(shared_ptr<widget>, int priority)
  no process(shared_ptr<T>(new T), computePriority())
  no shared_ptr<T> sp(new T, customDel)
     process(sp, computePriority())   performance: copy
  yes process(move(sp), computePriority())

Not to use make_unique, make_shared:
1. custom delete. not supported
2. make function use perfect forwarding, parentheses, not braces. 
using braced initialized, need to use new directly. 
Or auto initList = {10, 20}
auto spv = make_shared<vector<int>>(initList);
3. As long as weak_ptr refere to a control block, control block needs to exist. 
The memory containing it should remain allocated. 
If the obj is large and the time between destructio nof the last shared_ptr/week_ptr is significant, 
a lag can occur between when an obj is freed and when memory occupied is freed.

*****************************************************************************************************************************************************************************

placement new:
1. pointer you pass to the “placement new” operator points to a region of memory that is big enough 
2. is properly aligned for the object type that you’re creating

deletion: call destructor
only delete memeroy for new
    // buffer on stack
    unsigned char buf[sizeof(int)*2] ;
  
    // placement new in buf
    int *pInt = new (buf) int(3);
    int *qInt = new (buf + sizeof (int)) int(5);
    
  char memory[sizeof(Fred)]; // memory allocation
  void* p = memory;
  Fred* f = new(p) Fred();   // construct
  // ...
  f-       p->~T();
       }

       // deallocate storage p of deleted elements
       void deallocate (pointer p, size_type num) {
           // print message and deallocate memory with global delete
           std::cerr << "deallocate " << num << " element(s)"
                     << " of size " << sizeof(T)
                     << " at: " << (void*)p << std::endl;
           ::operator delete((void*)p);
       }
   };

std::construct_at:
Creates a T object initialized with arguments args... at given address p.
    S* ptr = std::construct_at(reinterpret_cast<S*>(storage), 42, 2.71828f, 3.1415);
    ptr->print(); 
    std::destroy_at(ptr);>~Fred();   // Explicitly call the destructor for the placed object

std::allocator is used to separate allocation and do construction in two steps, also separate destruction and deallocation
allocator is the memory allocator for the STL containers. 
a call of vec.reserve(n) of a vector vec allocates only memory for at least n elements. 
The constructor for each element will not be executed. also v.clear()
    allocator can be adjusted according to the container of your need, for example, vector where you only want to allocate occasionally.
    On the contrary, new doesn’t allow to have control over which constructors are called and simply construct all objects at the same time. 


    allocator<int> myAllocator;
    // allocate space for five ints
    int* arr = myAllocator.allocate(5);
 
    // construct arr[0] and arr[3]
    // myAllocator.construct(arr, 100); // no longer allowed in C++20
    arr[0] = 100; // do this instead
    arr[3] = 10;

    // deallocate space for five ints
    myAllocator.deallocate(arr, 5);    

implementation
	// allocate function uses the operator new function to allocate memory
	// The construct function uses placement-new to construct objects
       // allocate but don't initialize num elements of type T
       pointer allocate (size_type num, const void* = 0) {
           // print message and allocate memory with global new
           std::cerr << "allocate " << num << " element(s)"
                     << " of size " << sizeof(T) << std::endl;
           pointer ret = (pointer)(::operator new(num*sizeof(T)));
           std::cerr << " allocated at: " << (void*)ret << std::endl;
           return ret;
       }

       // initialize elements of allocated storage p with value value
       void construct (pointer p, const T& value) {
           // initialize memory with placement new
           new((void*)p)T(value);
       }

       // destroy elements of initialized storage p
       void destroy (pointer p) {
           // destroy objects by calling their destructor
           p->~T();
       }

       // deallocate storage p of deleted elements
       void deallocate (pointer p, size_type num) {
           // print message and deallocate memory with global delete
           std::cerr << "deallocate " << num << " element(s)"
                     << " of size " << sizeof(T)
                     << " at: " << (void*)p << std::endl;
           ::operator delete((void*)p);
       }
   };

std::construct_at:
Creates a T object initialized with arguments args... at given address p.
    S* ptr = std::construct_at(reinterpret_cast<S*>(storage), 42, 2.71828f, 3.1415);
    ptr->print(); 
    std::destroy_at(ptr);

https://codereview.stackexchange.com/questions/255149/stdvector-allocator-aware-implementation
#include <iostream>

using namespace std;

template<typename T>
class myVector
{
public:
    myVector()
    {
        _capacity = 2;
        _data = _a.allocate(_capacity);
    }    
    myVector(int n)
    {
        _data = _a.allocate(n);
        _capacity = n;
    }
    
    myVector(int n, const T& e)
    {
        _data = allocator_traits<allocator<T>>::allocate(_a, n);
        for(size_t i=0; i<n; i++)
            allocator_traits<allocator<T>>::construct(_a, _data+i, e);
        _size = _capacity = n;
    }
    
    myVector(const myVector& v)
    {
        _size = v._size;
        _capacity = v._capacity;

        if(v._data == nullptr)
            _data = nullptr;
        else
        {
            _data = allocator_traits<allocator<T>>::allocate(_a, _capacity);
            for(size_t i=0; i<_size; i++)
                allocator_traits<allocator<T>>::construct(_a, _data+i, *(v._data+i));
        }
    }
    
    myVector(myVector<T>&& v)
    {
        _data = v._data;
        _size = v._size;
        _capacity = v._capacity;
        _a = move(v._a);
        
        v._data = nullptr;
        v._size = 0;
        v._capacity = 0;
    }
    
    ~myVector()
    {
        for (std::size_t i = 0; i < _size; ++i)
            allocator_traits<allocator<T>>::destroy(_a, _data + i);
        allocator_traits<allocator<T>>::deallocate(_a, _data, _capacity);
        _size = _capacity = 0;
        _data = nullptr;
    }
    
    T& operator[] (size_t i)
    {
        return _data[i];
    }
    
    template<typename U>
    void push_back(U&& e)
    {
        if(_size < _capacity)
        {
            allocator_traits<allocator<T>>::construct(_a, _data+_size, forward<U>(e));
            _size ++;
        }
        else
        {
            T* temp = allocator_traits<allocator<T>>::allocate(_a, _capacity*2);
            for(size_t i=0; i<_size; i++)
                allocator_traits<allocator<T>>::construct(_a, temp+i, forward<T>(_data[i]));                        
            allocator_traits<allocator<T>>::construct(_a, temp+_size, forward<U>(e));
                        
            for (std::size_t i = 0; i < _size; ++i)
                allocator_traits<allocator<T>>::destroy(_a, _data + i);
            allocator_traits<allocator<T>>::deallocate(_a, _data, _capacity);
            
            _data = temp;
            _size ++;
            _capacity *= 2;
        }           
    }
    
    inline size_t size() { return _size; }
    
private:
    size_t _size = 0;
    size_t _capacity = 2;
    T* _data = nullptr;
    allocator<T> _a;
};

int main()
{
    
    myVector<string> v;
    v.push_back(move("h1"));
    string s = "h2";
    v.push_back(s);
    v.push_back("h3");
    v.push_back("h4");
    
    
    /*
    myVector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);    */
    myVector<string> v2(v);
     for(size_t i=0; i<v2.size(); i++)
        cout << i << v2[i] << endl;
        
    
    return 0;
}

*****************************************************************************************************************************************************************************    
    std::ref, std::reference_wrapper
creates an object that behaves similarly to a reference
