#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <vector>

std::mutex mtx;
std::condition_variable cv;
int readers = 0;             // Number of active readers
int writers = 0;             // Number of active writers (0 or 1)
int waiting_writers = 0;     // Number of writers waiting
int shared_data = 0;

void reader(int id) {
    {
        std::unique_lock<std::mutex> lock(mtx);
        // Writer-priority: Wait if any writer is active or waiting
        cv.wait(lock, []() { return writers == 0 && waiting_writers == 0; });
        ++readers;
    }

    std::cout << "[Reader " << id << "] reads value " << shared_data << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate reading

    {
        std::unique_lock<std::mutex> lock(mtx);
        --readers;
        if (readers == 0)
            cv.notify_all(); // Wake up writers if no more readers
    }
}

void writer(int id) {
    {
        std::unique_lock<std::mutex> lock(mtx);
        ++waiting_writers;
        cv.wait(lock, []() { return readers == 0 && writers == 0; });
        --waiting_writers;
        ++writers;
    }

    ++shared_data;
    std::cout << "[Writer " << id << "] writes value " << shared_data << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(150)); // Simulate writing

    {
        std::unique_lock<std::mutex> lock(mtx);
        --writers;
        cv.notify_all(); // Wake up readers or writers
    }
}

int main() {
    std::vector<std::thread> threads;
    // Example: interleave readers and writers
    for (int i = 1; i <= 3; ++i) threads.emplace_back(reader, i);
    for (int i = 1; i <= 2; ++i) threads.emplace_back(writer, i);
    for (int i = 4; i <= 6; ++i) threads.emplace_back(reader, i);
    for (auto& t : threads) t.join();
    return 0;
}
