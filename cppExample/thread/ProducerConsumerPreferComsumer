#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <vector>

std::mutex mtx;
std::condition_variable cv;
int readers = 0;
int writers = 0; // 0 or 1
int shared_data = 0;

void reader(int id) {
    {
        std::unique_lock<std::mutex> lock(mtx);
        // Reader-priority: Wait only if a writer is active
        cv.wait(lock, []() { return writers == 0; });
        ++readers;
    }

    std::cout << "[Reader " << id << "] reads value " << shared_data << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    {
        std::unique_lock<std::mutex> lock(mtx);
        --readers;
        if (readers == 0)
            cv.notify_all();
    }
}

void writer(int id) {
    {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []() { return readers == 0 && writers == 0; });
        ++writers;
    }

    ++shared_data;
    std::cout << "[Writer " << id << "] writes value " << shared_data << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(150));

    {
        std::unique_lock<std::mutex> lock(mtx);
        --writers;
        cv.notify_all();
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 1; i <= 3; ++i) threads.emplace_back(reader, i);
    for (int i = 1; i <= 2; ++i) threads.emplace_back(writer, i);
    for (int i = 4; i <= 6; ++i) threads.emplace_back(reader, i);
    for (auto& t : threads) t.join();
    return 0;
}
