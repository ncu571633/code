HashMap(unordered_map)

1. Separate chaining
2. Open addressing

Array for buckets. 

follow pointers in order to search linked lists. 
The upside is that chained hash tables only get linearly slower as the load factor (the ratio of elements in the hash table to the length of the bucket array) increases, even if it rises above 1.

Every entry record is stored in the bucket array itself.
When a new entry has to be inserted, the buckets are examined, starting with the hashed-to slot and proceeding in some probe sequence, until an unoccupied slot is found. 
When searching for an entry, the buckets are scanned in the same sequence, until either the target record is found, or an unused array slot is found, which indicates an unsuccessful search.

Insert: beginning with the cell at index h(k) 
until finding either an empty cell or a cell whose stored key is k

Advantage:
1. Open-addressing is usually faster than chained hashing when the load factor is low because you don't have to follow pointers between list nodes.
It gets very, very slow if the load factor approaches 1 
2. Open addressing hash map could be full. 
When load factor is larger than the threshold, make bucket array larger(allocating a new bucket array, and copying elements from the old one into the new one, then freeing the old one)
3. Open addressing: cache friendly. array, CPU can load the data in the cache line. 
Avoid dynamic memory allocation during computation.
use smaller data types: link list used more memory to store pointer. 

#include<print>
#include<list>
#include<vector>
#include<functional>
#include<iterator>

template<typename K, typename V>
class hash_map
{
public:
	using bucketType = std::list<std::pair<K, V>>;
	hash_map()
		: _capacity(2)
	{
		buckets = new bucketType[_capacity];
	}

	hash_map(const size_t capacity)
		: _capacity(capacity)
	{
		buckets = new bucketType[_capacity];
	}

    ~hash_map()
    {
        delete []buckets;
    }
    
	hash_map(const hash_map& m)
	{
		_size = m._size;
		_capacity = m._capacity;

		if (m.buckets == nullptr)
		{
			buckets = nullptr;
		}
		else
		{
			buckets = new bucketType[_capacity];
			for (int i = 0; i < _capacity; i++)
			{
				if (m.buckets[i])
				{
					buckets[i] = std::list<std::pair<K, V>>(m.buckets[i].begin(), m.buckets[i].begin());
				}
			}
		}
	}

    hash_map(hash_map&& other) noexcept
        : _size(other._size),
          _capacity(other._capacity),
          buckets(std::move(other.buckets))
    {
        other._size = 0;
        other._capacity = 0;
    }

	void insert(K key, V val) 
	{
		auto it = find(key);
		int index = getIndex(key);
		if (it != buckets[index].end()) 
		{
			it->second = val;
			return;
		}
		buckets[index].push_back({ key,val });
		_size++;
	}

	// typename list<pair<K, V>>::iterator find(K key)
	auto find(K key)
	{
		int index = getIndex(key);
		// for (auto& i: buckets[index])
		for (auto i = buckets[index].begin(); i != buckets[index].end(); ++i)
		{
			if (i->first == key) 
			{
				return i;
			}
		}

		return buckets[index].end();
	}

	void erase(int key) 
	{
		auto it = find(key);
		int index = getIndex(key);
		if (it != buckets[index].end())
		{
			buckets[index].erase(it);
			_size--;
		}
	}

	V& operator[] (K k)
	{
		auto it = find(k);
		int index = getIndex(k);
		if (it != buckets[index].end()) 
		{
			return it->second;
		}
		return it->second;
	}

#if false
	void rehashIfNeeded() {
		if (total_elements / bucket_size <= max_load_factor) {
			return;
		}
		bucket_size *= 2;
		auto new_buckets = new list<pair<int, int>>[bucket_size];
		for (int i = 0; i < bucket_size / 2; i++) {
			for (auto& kv_itr : buckets[i]) {
				new_buckets[hash(kv_itr->first)].push_back(*kv_itr);
			}
		}
		delete[] buckets;
		buckets = new_buckets;
	}
#endif

private:
	int getIndex(K k)
	{
		std::hash<K> hash_obj;
		return hash_obj(k) % _capacity;
	}

	std::list<std::pair<K, V>>* buckets;
	size_t _size = 0;
	size_t _capacity = 2;
};

int main()
{
	hash_map<int, std::string> m;
	m.insert(1, "1");
	m.insert(2, "2");
	m.insert(3, "3");
	m.insert(4, "4");

	std::print("{}\n", m[3]);
	m[3] = "4";
	std::print("{}\n", m[3]);

	return 0;
}
