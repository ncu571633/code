#include<print>
#include<list>
#include<vector>
#include<functional>
#include<utility>

constexpr size_t CAPACITY = 2;
template<typename K, typename V>
class hash_map
{
public:
    hash_map():
        hash_map(CAPACITY)
    {}

    hash_map(size_t capacity)
        : _size(0),
        _capacity(capacity),
        bucketsStatus(std::vector<bool>(capacity, false))
    {
        _data = static_cast<std::pair<K, V>*>(::operator new(_capacity * sizeof(std::pair<K, V>)));
    }

    ~hash_map()
    {
        for (int i=0; i<_capacity; ++i)
        {
            if(bucketsStatus[i])
            {
                _data[i].~V();
            }
        }
        ::operator delete(_data);
        _size = _capacity = 0;
    }
    
    hash_map& operator=(const hash_map& other)
    {
        if (this == &other)
        {
            return *this;
        }
        
        _size = other._size;
        _capacity = other._capacity;
        bucketsStatus = other.bucketsStatus;
        _data = other._data;
    }

    hash_map(hash_map&& other)
    {
        if (this == &other)
        {
            return;
        }
        
        _size = std::exchange(other._size, 0);
        _capacity = std::exchange(other._capacity, 0);
        bucketsStatus = other.bucketsStatus;
        _data = other._data;
    }
    
    void insert(K&& key, V&& value)
    {
        if (_size == _capacity)
            return ;
        
        int index = getIndex(key);
        for(int i = index; ; )
        {
            if (!bucketsStatus[i])
            {
                bucketsStatus[i] = true;
                std::construct_at(_data + i, std::move(value));   
            }
            
            i++;
            if (i==_capacity)
                i = 0;
        }
    }
    
    void erase(K&& key)
    {
        if (_size == 0)
            return ;
        
        int index = getIndex(key);
        for(int i = index; ; )
        {
            if (!bucketsStatus[i])
                break;
            
            int index2 = getIndex(_data[i].first);
            if (index != index2)
                break;

            if (_data[i].first == key)
            {
                bucketsStatus[i] = false;
                std::destroy_at(_data + i);   
            }
            
            i++;
            if (i==_capacity)
                i = 0;
        }
    }
    
    V& operator [](K key)
    {
        int index = getIndex(key);
        for(int i = index; ; )
        {
            if (!bucketsStatus[i])
            {
                
            }
            
            int index2 = getIndex(_data[i].first);
            if (index != index2)
                break;

            if (_data[i].first == key)
            {
                bucketsStatus[i] = false;
                std::destroy_at(_data + i);   
            }
            
            i++;
            if (i==_capacity)
                i = 0;
        }
    }
    
    inline size_t size() { return _size; }
    
private:
    inline size_t getIndex(K key)
    {
        std::hash<K> h;
        return h(key) % _capacity;
    }

	std::pair<K, V>* _data = nullptr;
	std::vector<bool> bucketsStatus;
	size_t _size = 0;
	size_t _capacity = CAPACITY;
};

int main()
{
	hash_map<int, std::string> m;
	m.insert(1, "1");
	m.insert(2, "2");
	m.insert(3, "3");
	m.insert(4, "4");

    std::print("size: {}\n", m.size());
	std::print("{}\n", m[3]);
	m[3] = "4";
	std::print("{}\n", m[3]);
    
    m.erase(3);
    std::print("size: {}\n", m.size());
	return 0;
}
