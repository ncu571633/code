#include <iostream>
#include <memory>
#include <utility>

#include <print>

constexpr size_t DEFAULT_CAPACITY = 2;

template<typename T>
class myVector
{
public:
    myVector()
    : myVector(DEFAULT_CAPACITY)
    {}

    myVector(int n)
    {
        _capacity = n;
        _size = 0;
        _data = std::aligned_alloc(32, _capacity * sizeof(T));
        // _data = static_cast<T*>(std::aligned_alloc(32, _capacity * sizeof(T)));
    }
    
    myVector(int n, const T& e)
    {
        _size = _capacity = n;
        _data = std::aligned_alloc(32, _capacity * sizeof(T));
        for(size_t i=0; i<n; i++)
            std::construct_at(reinterpret_cast<T*>(_data) + i, e);
    }
    
    myVector(const myVector& v)
    {
        _size = v._size;
        _capacity = v._capacity;

        if(v._data == nullptr)
            _data = nullptr;
        else
        {
            _data = std::aligned_alloc(32, _capacity * sizeof(T));
            for(size_t i=0; i < _size; i++)
                std::construct_at(reinterpret_cast<T*>(_data) + i, v[i]);
        }
    }
    
    myVector(myVector<T>&& v)
    {
        _capacity = std::exchange(v._capacity, 0);
        _size = std::exchange(v._size, 0);
        _data = std::exchange(v._data, nullptr);
    }

        myVector& operator=(const myVector& other) 
        {
            if (this == &other) 
                return *this;
            
            for (size_t i=0; i < _size; ++i)
                std::destroy_at(_data + i);
                
            if (other._data)
            {
                if (other.size() > _capacity) 
                {
                    std::free(_data);

                    _capacity = other._capacity;
                    _data = std::aligned_alloc(32, _capacity * sizeof(T));
                }
                
                _size = other._size;
                for (size_t i=0; i < _size; ++i)
                {
                    std::construct_at(reinterpret_cast<T*>(_data) + i, other._data[i]);
                }

            }
            else 
            {
                _data = nullptr;
                _size = 0;
            }
            return *this;
        }
        
        constexpr myVector& operator=(myVector&& other) noexcept 
        {
             _size = std::exchange(other._size, 0);
            _capacity = std::exchange(other._capacity, 0);
            _data = std::exchange(other._data, nullptr);
            return *this;
        }
	
    ~myVector()
    {
        for (size_t i = 0; i < _size; ++i)
            std::destroy_at(_data + i);
        std::free(_data);
        _size = _capacity = 0;
        _data = nullptr;
    }
    
    T& operator[] (size_t i)
    {
        return _data[i];
    }

    template<typename U>
    void push_back(U&& e)
    {
        if(_size < _capacity)
        {
            std::construct_at(reinterpret_cast<T*>(_data) + _size, std::forward<U>(e));
            _size ++;
        }
        else
        {
            T* temp = std::aligned_alloc(32, 2 * _capacity * sizeof(T));
            for(size_t i=0; i<_size; i++)
            {
                std::construct_at(temp + i, forward<T>(_data[i]));
            }
            std::free(_data);
            _data = temp;
            _size ++;
            _capacity *= 2;
        }           
    }
    
    inline size_t size() { return _size; }
    
	private:
	    size_t _size = 0;
	    size_t _capacity = 2;
	    T* _data = nullptr;
	};
	
	int main()
	{
	    myVector<std::string> v;
	    v.push_back(std::move("h1"));
	    std::string s = "h2";
	    v.push_back(s);
	    v.push_back("h3");
	    v.push_back("h4");
	    
	    /*
	    myVector<int> v;
	    v.push_back(1);
	    v.push_back(2);
	    v.push_back(3);
	    v.push_back(4);    */
	    myVector<std::string> v2(v);
	    for(size_t i=0; i<v2.size(); i++)
	        std::print("{} {}\n", i, v2[i]);
	        
	    return 0;
}
